// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

use super::Table;
use bitfield_struct::bitfield;
use core::mem::size_of;
use open_enum::open_enum;
use size_of_val;
use static_assertions::const_assert_eq;
use thiserror::Error;
use zerocopy::FromBytes;
use zerocopy::FromZeros;
use zerocopy::Immutable;
use zerocopy::IntoBytes;
use zerocopy::KnownLayout;
use zerocopy::Unaligned;
use zerocopy::LE;
use zerocopy::U16;
use zerocopy::U32;
use zerocopy::U64;

#[repr(C, packed)]
#[derive(Copy, Clone, Debug, IntoBytes, Immutable, KnownLayout, FromBytes, Unaligned)]
pub struct Madt {
    pub apic_addr: u32,
    pub flags: u32,
}

impl Table for Madt {
    const SIGNATURE: [u8; 4] = *b"APIC";
}

pub const MADT_PCAT_COMPAT: u32 = 1 << 0;

open_enum! {
    #[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Unaligned)]
    pub enum MadtType: u8 {
        APIC = 0x0,
        IO_APIC = 0x1,
        INTERRUPT_SOURCE_OVERRIDE = 0x2,
        X2APIC = 0x9,
        GICC = 0xb,
        GICD = 0xc,
    }
}

#[repr(C, packed)]
#[derive(Copy, Clone, Debug, IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct MadtEntryHeader {
    pub typ: MadtType,
    pub length: u8,
}

#[repr(C, packed)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct MadtApic {
    pub typ: MadtType,
    pub length: u8,
    pub acpi_processor_uid: u8,
    pub apic_id: u8,
    pub flags: u32,
}

const_assert_eq!(size_of::<MadtApic>(), 8);

impl MadtApic {
    pub fn new() -> Self {
        Self {
            typ: MadtType::APIC,
            length: size_of::<Self>() as u8,
            acpi_processor_uid: 0,
            apic_id: 0,
            flags: 0,
        }
    }
}

pub const MADT_APIC_ENABLED: u32 = 1 << 0;
pub const MADT_APIC_ONLINE_CAPABLE: u32 = 1 << 1;

#[repr(C, packed)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct MadtX2Apic {
    pub typ: MadtType,
    pub length: u8,
    pub reserved: u16,
    pub x2_apic_id: u32,
    pub flags: u32,
    pub acpi_processor_uid: u32,
}

const_assert_eq!(size_of::<MadtX2Apic>(), 16);

impl MadtX2Apic {
    pub fn new() -> Self {
        Self {
            typ: MadtType::X2APIC,
            length: size_of::<Self>() as u8,
            reserved: 0,
            x2_apic_id: 0,
            flags: 0,
            acpi_processor_uid: 0,
        }
    }
}

#[repr(C, packed)]
#[derive(Copy, Clone, Debug, IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct MadtIoApic {
    pub typ: MadtType,
    pub length: u8,
    pub io_apic_id: u8,
    pub rsvd: u8,
    pub io_apic_address: u32,
    pub global_system_interrupt_base: u32,
}

const_assert_eq!(size_of::<MadtIoApic>(), 12);

impl MadtIoApic {
    pub fn new() -> Self {
        Self {
            typ: MadtType::IO_APIC,
            length: size_of::<Self>() as u8,
            io_apic_id: 0,
            rsvd: 0,
            io_apic_address: 0,
            global_system_interrupt_base: 0,
        }
    }
}

#[repr(C, packed)]
#[derive(Copy, Clone, Debug, IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct MadtInterruptSourceOverride {
    pub typ: MadtType,
    pub length: u8,
    pub bus: u8,
    pub source: u8,
    pub gsi: u32,
    pub flags: u16,
}

const_assert_eq!(size_of::<MadtInterruptSourceOverride>(), 10);

pub enum InterruptPolarity {
    ActiveLow,
    ActiveHigh,
}

pub enum InterruptTriggerMode {
    Edge,
    Level,
}

impl MadtInterruptSourceOverride {
    pub fn new(
        source: u8,
        gsi: u32,
        polarity: Option<InterruptPolarity>,
        trigger_mode: Option<InterruptTriggerMode>,
    ) -> Self {
        Self {
            typ: MadtType::INTERRUPT_SOURCE_OVERRIDE,
            length: size_of::<Self>() as u8,
            bus: 0,
            source,
            gsi,
            flags: match polarity {
                None => 0,
                Some(InterruptPolarity::ActiveHigh) => 1,
                Some(InterruptPolarity::ActiveLow) => 3,
            } | (match trigger_mode {
                None => 0,
                Some(InterruptTriggerMode::Edge) => 1,
                Some(InterruptTriggerMode::Level) => 3,
            } << 2),
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug, IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct MadtGicd {
    pub typ: MadtType,
    pub length: u8,
    pub reserved: u16,
    pub gic_id: u32,
    pub base_address: u64,
    pub reserved2: u32,
    pub gic_version: u8,
    pub reserved3: [u8; 3],
}

const_assert_eq!(size_of::<MadtGicd>(), 24);

impl MadtGicd {
    pub fn new(gic_id: u32, base_address: u64, gic_version: u8) -> Self {
        Self {
            typ: MadtType::GICD,
            length: size_of::<Self>() as u8,
            reserved: 0,
            gic_id,
            base_address,
            reserved2: 0,
            gic_version,
            reserved3: [0; 3],
        }
    }
}

// TODO: use LE types everywhere, as here, to avoid #[repr(packed)] and to be
// specific about endianness (which the ACPI spec dictates is always LE).
#[repr(C)]
#[derive(Copy, Clone, Debug, IntoBytes, Immutable, KnownLayout, FromBytes, Unaligned)]
pub struct MadtGicc {
    pub typ: MadtType,
    pub length: u8,
    pub reserved: [u8; 2],
    pub cpu_interface_number: U32<LE>,
    pub acpi_processor_uid: U32<LE>,
    pub flags: U32<LE>,
    pub parking_protocol_version: U32<LE>,
    pub performance_monitoring_gsiv: U32<LE>,
    pub parked_address: U64<LE>,
    pub base_address: U64<LE>,
    pub gicv: U64<LE>,
    pub gich: U64<LE>,
    pub vgic_maintenance_interrupt: U32<LE>,
    pub gicr_base_address: U64<LE>,
    pub mpidr: U64<LE>,
    pub processor_power_efficiency_class: u8,
    pub reserved2: u8,
    pub spe_overflow_interrupt: U16<LE>,
}

const_assert_eq!(size_of::<MadtGicc>(), 80);

impl MadtGicc {
    pub fn new(acpi_processor_uid: u32, mpidr: u64, gicr: u64) -> Self {
        Self {
            typ: MadtType::GICC,
            length: size_of::<Self>() as u8,
            flags: u32::from(MadtGiccFlags::new().with_enabled(true)).into(),
            acpi_processor_uid: acpi_processor_uid.into(),
            mpidr: mpidr.into(),
            gicr_base_address: gicr.into(),
            ..Self::new_zeroed()
        }
    }
}

#[bitfield(u32)]
pub struct MadtGiccFlags {
    pub enabled: bool,
    #[bits(31)]
    _reserved: u32,
}

/// A MADT parser that can be iterated through for different [`MadtEntry`].
pub struct MadtParser<'a>(&'a [u8]);

impl<'a> MadtParser<'a> {
    /// Partially an MADT table.
    pub fn new(table: &'a [u8]) -> Result<Self, ParserError> {
        let header = crate::Header::read_from_prefix(table)
            .map_err(|_| ParserError)?
            .0; // TODO: zerocopy: map_err (https://github.com/microsoft/openvmm/issues/759)
        if (header.length.get() as usize) < size_of::<Madt>() {
            return Err(ParserError);
        }
        let off = size_of_val(&header);
        let table = table
            .get(off..header.length.get() as usize)
            .ok_or(ParserError)?;
        Ok(Self(table))
    }

    /// Returns an iterator to parse the MADT entries.
    pub fn entries(&self) -> MadtIter<'_> {
        MadtIter {
            entries: &self.0[size_of::<Madt>()..],
        }
    }

    /// Parse apic_ids from the given MADT for enabled processors. Returned as a
    /// `Vec<Option<u32>>` with element 0 being processor_acpi_uid 1.
    #[cfg(feature = "alloc")]
    pub fn parse_apic_ids(&self) -> Result<alloc::vec::Vec<Option<u32>>, ParseApicIdError> {
        use alloc::vec::Vec;

        let mut apic_ids: Vec<Option<u32>> = Vec::new();

        for entry in self.entries() {
            let (uid, apic_id) = match entry.map_err(ParseApicIdError::Parser)? {
                MadtEntry::Apic(apic) => {
                    if apic.flags & MADT_APIC_ENABLED == MADT_APIC_ENABLED {
                        (apic.acpi_processor_uid as u32, apic.apic_id as u32)
                    } else {
                        continue;
                    }
                }
                MadtEntry::X2Apic(x2apic) => {
                    if x2apic.flags & MADT_APIC_ENABLED == MADT_APIC_ENABLED {
                        (x2apic.acpi_processor_uid, x2apic.x2_apic_id)
                    } else {
                        continue;
                    }
                }
            };

            // ACPI uids start at 1.
            let index = uid as usize - 1;

            if apic_ids.get(index).is_none() {
                apic_ids.resize(index + 1, None);
            }

            if apic_ids[index].replace(apic_id).is_some() {
                return Err(ParseApicIdError::ProcessorNotUnique(uid));
            }
        }

        Ok(apic_ids)
    }
}

/// MADT parsing error.
#[derive(Debug, Error)]
#[error("madt parsing failed")]
pub struct ParserError;

/// parse_apic_ids error
#[derive(Debug, thiserror::Error)]
pub enum ParseApicIdError {
    #[error("error parsing entry")]
    Parser(#[source] ParserError),
    #[error("processor_acpi_uid specified more than once in the MADT")]
    ProcessorNotUnique(u32),
}

/// The MADT entry type.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MadtEntry {
    /// An APIC entry
    Apic(MadtApic),
    /// An X2 APIC entry
    X2Apic(MadtX2Apic),
}

/// The MADT iterator. Ignores unknown entries.
pub struct MadtIter<'a> {
    entries: &'a [u8],
}

impl MadtIter<'_> {
    fn parse(&mut self) -> Result<Option<MadtEntry>, ParserError> {
        // TODO: zerocopy: map_err (https://github.com/microsoft/openvmm/issues/759)
        while let Ok((header, _)) = MadtEntryHeader::read_from_prefix(self.entries) {
            // TODO: zerocopy: ok (https://github.com/microsoft/openvmm/issues/759)
            if self.entries.len() < header.length as usize {
                return Err(ParserError);
            }
            let (buf, rest) = self.entries.split_at(header.length as usize);
            self.entries = rest;
            let entry = match header.typ {
                MadtType::APIC => {
                    MadtEntry::Apic(FromBytes::read_from_prefix(buf).map_err(|_| ParserError)?.0)
                    // TODO: zerocopy: map_err (https://github.com/microsoft/openvmm/issues/759)
                }
                MadtType::X2APIC => {
                    MadtEntry::X2Apic(FromBytes::read_from_prefix(buf).map_err(|_| ParserError)?.0)
                    // TODO: zerocopy: map_err (https://github.com/microsoft/openvmm/issues/759)
                }
                _ => continue,
            };
            return Ok(Some(entry));
        }
        Ok(None)
    }
}

impl Iterator for MadtIter<'_> {
    type Item = Result<MadtEntry, ParserError>;

    fn next(&mut self) -> Option<Self::Item> {
        self.parse().transpose()
    }
}

// TODO: could check-in binary files and do `include_bytes!()`
#[cfg(test)]
mod test {
    use super::*;
    #[cfg(feature = "alloc")]
    use alloc::vec;
    #[cfg(feature = "alloc")]
    use alloc::vec::Vec;

    // test sparse madt with not sequential processors enabled
    #[test]
    #[cfg(feature = "alloc")]
    fn sparse_madt() {
        const DATA: &[u8] = &[
            65, 80, 73, 67, 194, 0, 0, 0, 5, 195, 72, 86, 76, 73, 84, 69, 72, 86, 76, 73, 84, 69,
            84, 66, 0, 0, 0, 0, 77, 83, 72, 86, 0, 0, 0, 0, 0, 0, 224, 254, 0, 0, 0, 0, 1, 12, 16,
            0, 0, 0, 192, 254, 0, 0, 0, 0, 2, 10, 0, 2, 2, 0, 0, 0, 13, 0, 0, 8, 1, 0, 1, 0, 0, 0,
            0, 8, 4, 1, 1, 0, 0, 0, 0, 8, 6, 2, 1, 0, 0, 0, 0, 8, 8, 3, 1, 0, 0, 0, 0, 8, 10, 4, 1,
            0, 0, 0, 0, 8, 12, 5, 1, 0, 0, 0, 0, 8, 14, 6, 1, 0, 0, 0, 0, 8, 16, 7, 1, 0, 0, 0, 0,
            8, 18, 8, 1, 0, 0, 0, 0, 8, 20, 9, 1, 0, 0, 0, 0, 8, 22, 10, 1, 0, 0, 0, 0, 8, 24, 11,
            1, 0, 0, 0, 0, 8, 26, 12, 1, 0, 0, 0, 0, 8, 28, 13, 1, 0, 0, 0, 0, 8, 30, 14, 1, 0, 0,
            0, 0, 8, 32, 15, 1, 0, 0, 0,
        ];

        let madt = MadtParser::new(DATA).unwrap();
        let entries = madt.parse_apic_ids().unwrap();

        assert_eq!(
            entries,
            vec![
                Some(0),
                None,
                None,
                Some(1),
                None,
                Some(2),
                None,
                Some(3),
                None,
                Some(4),
                None,
                Some(5),
                None,
                Some(6),
                None,
                Some(7),
                None,
                Some(8),
                None,
                Some(9),
                None,
                Some(10),
                None,
                Some(11),
                None,
                Some(12),
                None,
                Some(13),
                None,
                Some(14),
                None,
                Some(15)
            ]
        );
    }

    #[test]
    fn single_apic() {
        // single APIC
        const DATA: &[u8] = &[
            0x41, 0x50, 0x49, 0x43, 0x50, 0x00, 0x00, 0x00, 0x04, 0x23, 0x56, 0x52, 0x54, 0x55,
            0x41, 0x4c, 0x4d, 0x49, 0x43, 0x52, 0x4f, 0x53, 0x46, 0x54, 0x01, 0x00, 0x00, 0x00,
            0x4d, 0x53, 0x46, 0x54, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfe, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x0c, 0x01, 0x00, 0x00, 0x00, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00,
            0x02, 0x0a, 0x00, 0x09, 0x09, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x04, 0x06, 0x01, 0x00,
            0x00, 0x01, 0x00, 0x08, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        ];

        let madt = MadtParser::new(DATA).unwrap();

        let entries = madt.entries().collect::<Result<Vec<_>, _>>().unwrap();

        assert_eq!(
            entries[0],
            MadtEntry::Apic(MadtApic {
                typ: MadtType::APIC,
                length: 8,
                acpi_processor_uid: 1,
                apic_id: 0,
                flags: 1,
            })
        );
    }

    #[test]
    #[cfg(feature = "alloc")]
    fn madt_50_vps() {
        const DATA: &[u8] = &[
            0x41, 0x50, 0x49, 0x43, 0xd8, 0x01, 0x00, 0x00, 0x04, 0x06, 0x56, 0x52, 0x54, 0x55,
            0x41, 0x4c, //  APIC......VRTUAL
            0x4d, 0x49, 0x43, 0x52, 0x4f, 0x53, 0x46, 0x54, 0x01, 0x00, 0x00, 0x00, 0x4d, 0x53,
            0x46, 0x54, //  MICROSFT....MSFT
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0a,
            0x00, 0x09, //  ................
            0x09, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x04, 0x06, 0x01, 0x00, 0x00, 0x01, 0x01, 0x0c,
            0x32, 0x00, //  ..............2.
            0x00, 0x00, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x03, 0x02, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x04, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x05, 0x04, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x06, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x07, 0x06, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x08, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x08, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x0a, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0b, 0x0a, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x0c, 0x0b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0d, 0x0c, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x0e, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x11, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x10, 0x12, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x11, 0x13, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x12, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x13, 0x15, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x14, 0x16, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x15, 0x17, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x16, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x17, 0x19, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x18, 0x1a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x19, 0x1b, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x1a, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1b, 0x20, 0x01, 0x00,
            0x00, 0x00, //  ........... ....
            0x00, 0x08, 0x1c, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1d, 0x22, 0x01, 0x00,
            0x00, 0x00, //  ...!......."....
            0x00, 0x08, 0x1e, 0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1f, 0x24, 0x01, 0x00,
            0x00, 0x00, //  ...#.......$....
            0x00, 0x08, 0x20, 0x25, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x21, 0x26, 0x01, 0x00,
            0x00, 0x00, //  .. %......!&....
            0x00, 0x08, 0x22, 0x27, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x23, 0x28, 0x01, 0x00,
            0x00, 0x00, //  .."'......#(....
            0x00, 0x08, 0x24, 0x29, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x25, 0x2a, 0x01, 0x00,
            0x00, 0x00, //  ..$)......%*....
            0x00, 0x08, 0x26, 0x2b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x27, 0x30, 0x01, 0x00,
            0x00, 0x00, //  ..&+......'0....
            0x00, 0x08, 0x28, 0x31, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x29, 0x32, 0x01, 0x00,
            0x00, 0x00, //  ..(1......)2....
            0x00, 0x08, 0x2a, 0x33, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x2b, 0x34, 0x01, 0x00,
            0x00, 0x00, //  ..*3......+4....
            0x00, 0x08, 0x2c, 0x35, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x2d, 0x36, 0x01, 0x00,
            0x00, 0x00, //  ..,5......-6....
            0x00, 0x08, 0x2e, 0x37, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x2f, 0x38, 0x01, 0x00,
            0x00, 0x00, //  ...7....../8....
            0x00, 0x08, 0x30, 0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x31, 0x3a, 0x01, 0x00,
            0x00, 0x00, //  ..09......1:....
            0x00, 0x08, 0x32, 0x3b, 0x01, 0x00, 0x00, 0x00, // ..2;....
        ];

        let madt = MadtParser::new(DATA).unwrap();

        let entries = madt.entries().collect::<Result<Vec<_>, _>>().unwrap();

        assert_eq!(entries.len(), 50);
        assert!(matches!(
            entries[0],
            MadtEntry::Apic(MadtApic {
                typ: MadtType::APIC,
                length: 8,
                acpi_processor_uid: 1,
                apic_id: 0,
                flags: 1
            })
        ));
        assert!(matches!(
            entries[49],
            MadtEntry::Apic(MadtApic {
                typ: MadtType::APIC,
                length: 8,
                acpi_processor_uid: 50,
                apic_id: 59,
                flags: 1
            })
        ));

        let entries = madt.parse_apic_ids().unwrap();

        assert_eq!(
            entries,
            (0..13)
                .chain(16..29)
                .chain(32..44)
                .chain(48..60)
                .map(Some)
                .collect::<Vec<_>>()
        );
    }

    #[test]
    #[cfg(feature = "alloc")]
    fn madt_256() {
        const DATA: &[u8] = &[
            0x41, 0x50, 0x49, 0x43, 0x50, 0x08, 0x00, 0x00, 0x04, 0x14, 0x56, 0x52, 0x54, 0x55,
            0x41, 0x4c, //  APICP.....VRTUAL
            0x4d, 0x49, 0x43, 0x52, 0x4f, 0x53, 0x46, 0x54, 0x01, 0x00, 0x00, 0x00, 0x4d, 0x53,
            0x46, 0x54, //  MICROSFT....MSFT
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0a,
            0x00, 0x09, //  ................
            0x09, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x04, 0x06, 0x01, 0x00, 0x00, 0x01, 0x01, 0x0c,
            0x00, 0x00, //  ................
            0x00, 0x00, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x03, 0x02, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x04, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x05, 0x04, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x06, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x07, 0x06, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x08, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x08, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x0a, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0b, 0x0a, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x0c, 0x0b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0d, 0x0c, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x0e, 0x0d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x0e, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x10, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x11, 0x10, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x12, 0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x13, 0x12, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x14, 0x13, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x15, 0x14, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x16, 0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x17, 0x16, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x18, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x19, 0x18, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x1a, 0x19, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1b, 0x1a, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x1c, 0x1b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1d, 0x1c, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x1e, 0x1d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1f, 0x1e, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x20, 0x1f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x21, 0x20, 0x01, 0x00,
            0x00, 0x00, //  .. .......! ....
            0x00, 0x08, 0x22, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x23, 0x22, 0x01, 0x00,
            0x00, 0x00, //  .."!......#"....
            0x00, 0x08, 0x24, 0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x25, 0x24, 0x01, 0x00,
            0x00, 0x00, //  ..$#......%$....
            0x00, 0x08, 0x26, 0x25, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x27, 0x26, 0x01, 0x00,
            0x00, 0x00, //  ..&%......'&....
            0x00, 0x08, 0x28, 0x27, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x29, 0x28, 0x01, 0x00,
            0x00, 0x00, //  ..('......)(....
            0x00, 0x08, 0x2a, 0x29, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x2b, 0x2a, 0x01, 0x00,
            0x00, 0x00, //  ..*)......+*....
            0x00, 0x08, 0x2c, 0x2b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x2d, 0x2c, 0x01, 0x00,
            0x00, 0x00, //  ..,+......-,....
            0x00, 0x08, 0x2e, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x2f, 0x2e, 0x01, 0x00,
            0x00, 0x00, //  ...-....../.....
            0x00, 0x08, 0x30, 0x2f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x31, 0x30, 0x01, 0x00,
            0x00, 0x00, //  ..0/......10....
            0x00, 0x08, 0x32, 0x31, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x33, 0x32, 0x01, 0x00,
            0x00, 0x00, //  ..21......32....
            0x00, 0x08, 0x34, 0x33, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x35, 0x34, 0x01, 0x00,
            0x00, 0x00, //  ..43......54....
            0x00, 0x08, 0x36, 0x35, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x37, 0x36, 0x01, 0x00,
            0x00, 0x00, //  ..65......76....
            0x00, 0x08, 0x38, 0x37, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x39, 0x38, 0x01, 0x00,
            0x00, 0x00, //  ..87......98....
            0x00, 0x08, 0x3a, 0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x3b, 0x3a, 0x01, 0x00,
            0x00, 0x00, //  ..:9......;:....
            0x00, 0x08, 0x3c, 0x3b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x3d, 0x3c, 0x01, 0x00,
            0x00, 0x00, //  ..<;......=<....
            0x00, 0x08, 0x3e, 0x3d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x3f, 0x3e, 0x01, 0x00,
            0x00, 0x00, //  ..>=......?>....
            0x00, 0x08, 0x40, 0x3f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x41, 0x40, 0x01, 0x00,
            0x00, 0x00, //  ..@?......A@....
            0x00, 0x08, 0x42, 0x41, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x43, 0x42, 0x01, 0x00,
            0x00, 0x00, //  ..BA......CB....
            0x00, 0x08, 0x44, 0x43, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x45, 0x44, 0x01, 0x00,
            0x00, 0x00, //  ..DC......ED....
            0x00, 0x08, 0x46, 0x45, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x47, 0x46, 0x01, 0x00,
            0x00, 0x00, //  ..FE......GF....
            0x00, 0x08, 0x48, 0x47, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x49, 0x48, 0x01, 0x00,
            0x00, 0x00, //  ..HG......IH....
            0x00, 0x08, 0x4a, 0x49, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4b, 0x4a, 0x01, 0x00,
            0x00, 0x00, //  ..JI......KJ....
            0x00, 0x08, 0x4c, 0x4b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4d, 0x4c, 0x01, 0x00,
            0x00, 0x00, //  ..LK......ML....
            0x00, 0x08, 0x4e, 0x4d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4f, 0x4e, 0x01, 0x00,
            0x00, 0x00, //  ..NM......ON....
            0x00, 0x08, 0x50, 0x4f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x51, 0x50, 0x01, 0x00,
            0x00, 0x00, //  ..PO......QP....
            0x00, 0x08, 0x52, 0x51, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x53, 0x52, 0x01, 0x00,
            0x00, 0x00, //  ..RQ......SR....
            0x00, 0x08, 0x54, 0x53, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x55, 0x54, 0x01, 0x00,
            0x00, 0x00, //  ..TS......UT....
            0x00, 0x08, 0x56, 0x55, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x57, 0x56, 0x01, 0x00,
            0x00, 0x00, //  ..VU......WV....
            0x00, 0x08, 0x58, 0x57, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x59, 0x58, 0x01, 0x00,
            0x00, 0x00, //  ..XW......YX....
            0x00, 0x08, 0x5a, 0x59, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x5b, 0x5a, 0x01, 0x00,
            0x00, 0x00, //  ..ZY......[Z....
            0x00, 0x08, 0x5c, 0x5b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x5d, 0x5c, 0x01, 0x00,
            0x00, 0x00, //  ..\[......]\....
            0x00, 0x08, 0x5e, 0x5d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x5f, 0x5e, 0x01, 0x00,
            0x00, 0x00, //  ..^]......_^....
            0x00, 0x08, 0x60, 0x5f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x61, 0x60, 0x01, 0x00,
            0x00, 0x00, //  ..`_......a`....
            0x00, 0x08, 0x62, 0x61, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x63, 0x62, 0x01, 0x00,
            0x00, 0x00, //  ..ba......cb....
            0x00, 0x08, 0x64, 0x63, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x65, 0x64, 0x01, 0x00,
            0x00, 0x00, //  ..dc......ed....
            0x00, 0x08, 0x66, 0x65, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x67, 0x66, 0x01, 0x00,
            0x00, 0x00, //  ..fe......gf....
            0x00, 0x08, 0x68, 0x67, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x69, 0x68, 0x01, 0x00,
            0x00, 0x00, //  ..hg......ih....
            0x00, 0x08, 0x6a, 0x69, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x6b, 0x6a, 0x01, 0x00,
            0x00, 0x00, //  ..ji......kj....
            0x00, 0x08, 0x6c, 0x6b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x6d, 0x6c, 0x01, 0x00,
            0x00, 0x00, //  ..lk......ml....
            0x00, 0x08, 0x6e, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x6f, 0x6e, 0x01, 0x00,
            0x00, 0x00, //  ..nm......on....
            0x00, 0x08, 0x70, 0x6f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x71, 0x70, 0x01, 0x00,
            0x00, 0x00, //  ..po......qp....
            0x00, 0x08, 0x72, 0x71, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x73, 0x72, 0x01, 0x00,
            0x00, 0x00, //  ..rq......sr....
            0x00, 0x08, 0x74, 0x73, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x75, 0x74, 0x01, 0x00,
            0x00, 0x00, //  ..ts......ut....
            0x00, 0x08, 0x76, 0x75, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x77, 0x76, 0x01, 0x00,
            0x00, 0x00, //  ..vu......wv....
            0x00, 0x08, 0x78, 0x77, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x79, 0x78, 0x01, 0x00,
            0x00, 0x00, //  ..xw......yx....
            0x00, 0x08, 0x7a, 0x79, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x7b, 0x7a, 0x01, 0x00,
            0x00, 0x00, //  ..zy......{z....
            0x00, 0x08, 0x7c, 0x7b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x7d, 0x7c, 0x01, 0x00,
            0x00, 0x00, //  ..|{......}|....
            0x00, 0x08, 0x7e, 0x7d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x7f, 0x7e, 0x01, 0x00,
            0x00, 0x00, //  ..~}.......~....
            0x00, 0x08, 0x80, 0x7f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x81, 0x80, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x82, 0x81, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x83, 0x82, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x84, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x85, 0x84, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x86, 0x85, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x87, 0x86, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x88, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x89, 0x88, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x8a, 0x89, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x8b, 0x8a, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x8c, 0x8b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x8d, 0x8c, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x8e, 0x8d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x8f, 0x8e, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x90, 0x8f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x91, 0x90, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x92, 0x91, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x93, 0x92, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x94, 0x93, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x95, 0x94, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x96, 0x95, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x97, 0x96, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x98, 0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x99, 0x98, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x9a, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x9b, 0x9a, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x9c, 0x9b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x9d, 0x9c, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0x9e, 0x9d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x9f, 0x9e, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xa0, 0x9f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa1, 0xa0, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xa2, 0xa1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa3, 0xa2, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xa4, 0xa3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa5, 0xa4, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xa6, 0xa5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa7, 0xa6, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xa8, 0xa7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa9, 0xa8, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xaa, 0xa9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xab, 0xaa, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xac, 0xab, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xad, 0xac, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xae, 0xad, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xaf, 0xae, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xb0, 0xaf, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xb1, 0xb0, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xb2, 0xb1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xb3, 0xb2, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xb4, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xb5, 0xb4, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xb6, 0xb5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xb7, 0xb6, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xb8, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xb9, 0xb8, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xba, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xbb, 0xba, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xbc, 0xbb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xbd, 0xbc, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xbe, 0xbd, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xbf, 0xbe, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xc0, 0xbf, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xc1, 0xc0, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xc2, 0xc1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xc3, 0xc2, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xc4, 0xc3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xc5, 0xc4, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xc6, 0xc5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xc7, 0xc6, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xc8, 0xc7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xc9, 0xc8, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xca, 0xc9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xcb, 0xca, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xcc, 0xcb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xcd, 0xcc, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xce, 0xcd, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xcf, 0xce, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xd0, 0xcf, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xd1, 0xd0, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xd2, 0xd1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xd3, 0xd2, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xd4, 0xd3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xd5, 0xd4, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xd6, 0xd5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xd7, 0xd6, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xd8, 0xd7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xd9, 0xd8, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xda, 0xd9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xdb, 0xda, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xdc, 0xdb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xdd, 0xdc, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xde, 0xdd, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xdf, 0xde, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xe0, 0xdf, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xe1, 0xe0, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xe2, 0xe1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xe3, 0xe2, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xe4, 0xe3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xe5, 0xe4, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xe6, 0xe5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xe7, 0xe6, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xe8, 0xe7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xe9, 0xe8, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xea, 0xe9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xeb, 0xea, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xec, 0xeb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xed, 0xec, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xee, 0xed, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xef, 0xee, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xf0, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xf1, 0xf0, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xf2, 0xf1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xf3, 0xf2, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xf4, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xf5, 0xf4, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xf6, 0xf5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xf7, 0xf6, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xf8, 0xf7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xf9, 0xf8, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xfa, 0xf9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xfb, 0xfa, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xfc, 0xfb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xfd, 0xfc, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x00, 0x08, 0xfe, 0xfd, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0xff, 0xfe, 0x01, 0x00,
            0x00, 0x00, //  ................
            0x09, 0x10, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,
            0x00, 0x00, //  ................
        ];

        let madt = MadtParser::new(DATA).unwrap();

        let entries = madt.entries().collect::<Result<Vec<_>, _>>().unwrap();

        assert!(entries.len() == 256);
        assert!(matches!(
            entries[0],
            MadtEntry::Apic(MadtApic {
                typ: MadtType::APIC,
                length: 8,
                acpi_processor_uid: 1,
                apic_id: 0,
                flags: 1
            })
        ));
        assert!(matches!(
            entries[255],
            MadtEntry::X2Apic(MadtX2Apic {
                typ: MadtType::X2APIC,
                length: 16,
                reserved: 0,
                x2_apic_id: 255,
                flags: 1,
                acpi_processor_uid: 256
            })
        ));

        let entries = madt.parse_apic_ids().unwrap();

        assert_eq!(entries, (0..256).map(Some).collect::<Vec<_>>());
    }
}
